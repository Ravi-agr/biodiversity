from django.shortcuts import renderfrom django.http import HttpResponse, Http404from biodiv.models import *import jsonerror_response = {"error":"Invalid API URL"}def apiSpecies(request, id, type):    #Retrieving Species with Species ID = id from table Species    try:        species = Species.objects.get(species_id=id)    except Species.DoesNotExist:        return HttpResponse(json.dumps(error_response), content_type="application/json")        #Record retrieved    response_data = {}    if type == "name":        response_data['species_id'] = species.species_id        if species.scientific_name:            response_data['name'] = species.scientific_name        else:            response_data['name'] = species.name        #Retrieving Synonyms, Accepted names from table Names        catalouge_name = Names.objects.filter(species_id = id)        if catalouge_name:            response_data['accepted_name'] = catalouge_name[0].accepted_name + " " + catalouge_name[0].accepted_authority        else:            response_data['accepted_name'] = "N/A"        response_data['synonyms'] = []        for item in catalouge_name:            response_data['synonyms'].append(item.synonym + " " + item.authority)            #Record(s) retrieved        #Retrieving Common Names from table Common Names        common_list = CommonNames.objects.filter(species_id=id)        response_data['common_names'] = []        for item in common_list:            response_data['common_names'].append(item.common_name)            #Record(s) retrieved    elif type == "classification":        clazz = Classification.objects.get(species_id = id)        response_data = {"species_id": id,                         "kingdom": clazz.kingdom,                         "phylum": clazz.phylum,                         "clazz": clazz.class_field,                         "order": clazz.order,                         "family": clazz.family,                         "genus": clazz.genus,                         "scientific_name": species.scientific_name        }    elif type == "status":        try:            iucn = IucnData.objects.get(species_id = id)            response_data["iucn_status"] = iucn.status        except IucnData.DoesNotExist:            response_data["iucn_status"] = "Not Listed"        try:            others = Status.objects.get(species_id = id)            response_data["cites_appendix"] = others.cites            response_data["nrdb_status"] = others.nrdb            response_data["protected"] = others.protected if "Yes" else "No"            response_data["endemic"] = others.endemic if "Yes" else "No"        except Status.DoesNotExist:            response_data["cites_appendix"] = "Not Listed"            response_data["nrdb_status"] = "Not Listed"            response_data["protected"] = "No"            response_data["endemic"] = "No"    elif type == "protected_areas":        protected = SpeciesPa.objects.filter(species_id = id)        response_data["species_id"] = id        response_data["protected_areas"] = [];        for item in protected:            p = item.pa_id            pa = {"pa_id":p.pa_id, "name":p.name  , "designation":p.designation}            response_data["protected_areas"].append(pa)    else:        return HttpResponse(json.dumps(error_response), content_type="application/json")    return HttpResponse(json.dumps(response_data), content_type="application/json")def apiProtected(request,id,type):    try:        pa = ProtectedAreas.objects.get(pa_id = id)    except ProtectedAreas.DoesNotExist:        return HttpResponse(json.dumps(error_response), content_type="application/json")    response_data = {}    if type == "basics":        response_data = {"pa_id":pa.pa_id,                         "name":pa.name + " " + pa.designation,                         "type":pa.designation,                         "estd_year":pa.estd_year,                         "iucn_category":pa.iucn_category,                         "area":pa.area        }    elif type == "species_count":        response_data = ProtectedAreas.objects.speciesCount(id)    elif type == "species_checklist":        response_data = ProtectedAreas.objects.speciesChecklist(id)    else:        return HttpResponse(json.dumps(error_response), content_type="application/json")    return HttpResponse(json.dumps(response_data), content_type="application/json")def apiOthers(request,type, group = "all"):    response_data = {}    if type == "count":        response_data = Species.objects.speciesCount(group)    elif type == "checklist":        response_data = Species.objects.speciesChecklist(group)    else:        return HttpResponse(json.dumps(error_response), content_type="application/json")    return HttpResponse(json.dumps(response_data), content_type="application/json")def csvProtectedChecklist(request,id):    try:        pa = ProtectedAreas.objects.get(pa_id = id)    except ProtectedAreas.DoesNotExist:        return HttpResponse(json.dumps(error_response), content_type="application/json")    import csv    response_data = ProtectedAreas.objects.speciesChecklist(id)    response = HttpResponse(mimetype='text/csv')    response['Content-Disposition'] = 'attachment;filename=export.csv'    field_names = ["Species ID", "Group", "Name"]    writer = csv.writer(response)    writer.writerow(field_names)    for group,species in response_data.iteritems():        for item in species:            writer.writerow([item['species_id'],group, item['name']])    return responsedef csvSpeciesChecklist(request,group = 'all'):    import csv    response_data = Species.objects.speciesChecklist(group)    response = HttpResponse(mimetype='text/csv')    response['Content-Disposition'] = 'attachment;filename=export.csv'    if group == 'all':        field_names = ["Species ID", "Group", "Name"]    else:        field_names = ["Species ID", "Family", "Name"]    writer = csv.writer(response)    writer.writerow(field_names)    for group,species in response_data.iteritems():        for item in species:            writer.writerow([item['species_id'],group, item['name']])    return response#def suggestion(request, query):#    species = Species.objects.filter(name__contains = query)#    response_data = []#    for item in species:#        response_data.append({"Name":item.name, "Scientific Name": item.scientific_name})##    return HttpResponse(json.dumps(response_data), content_type="application/json")