from django.core.serializers.json import DjangoJSONEncoderfrom django.db.models.aggregates import Sumfrom django.db.models.query_utils import Qfrom django.shortcuts import renderfrom django.http import HttpResponse, Http404from biodiv.models import *from django.db.models import Countimport jsonerror_response = {"error": "Invalid API URL"}def apiSpecies(request, id, type):    #Retrieving Species with Species ID = id from table Species    try:        species = Species.objects.get(species_id=id)    except Species.DoesNotExist:        return HttpResponse(json.dumps(error_response), content_type="application/json")        #Record retrieved    response_data = {}    if type == "name":        response_data['species_id'] = species.species_id        if species.scientific_name:            response_data['name'] = species.scientific_name        else:            response_data['name'] = species.name        #Retrieving Synonyms, Accepted names from table Names        catalouge_name = Names.objects.filter(species_id=id)        if catalouge_name:            response_data['accepted_name'] = catalouge_name[0].accepted_name + " " + catalouge_name[                                                                                     0].accepted_authority        else:            response_data['accepted_name'] = "N/A"        response_data['synonyms'] = []        for item in catalouge_name:            response_data['synonyms'].append(item.synonym + " " + item.authority)            #Record(s) retrieved        #Retrieving Common Names from table Common Names        common_list = CommonNames.objects.filter(species_id=id)        response_data['common_names'] = []        for item in common_list:            response_data['common_names'].append(item.common_name)            #Record(s) retrieved    elif type == "classification":        clazz = Classification.objects.get(species_id=id)        response_data = {"species_id": id,                         "kingdom": clazz.kingdom,                         "phylum": clazz.phylum,                         "clazz": clazz.class_field,                         "order": clazz.order,                         "family": clazz.family,                         "genus": clazz.genus,                         "scientific_name": species.scientific_name        }    elif type == "status":        try:            iucn = IucnData.objects.get(species_id=id)            response_data["iucn_status"] = iucn.status        except IucnData.DoesNotExist:            response_data["iucn_status"] = "Not Listed"        try:            others = Status.objects.get(species_id=id)            response_data["cites_appendix"] = others.cites            response_data["nrdb_status"] = others.nrdb            response_data["protected"] = others.protected if "Yes" else "No"            response_data["endemic"] = others.endemic if "Yes" else "No"        except Status.DoesNotExist:            response_data["cites_appendix"] = "Not Listed"            response_data["nrdb_status"] = "Not Listed"            response_data["protected"] = "No"            response_data["endemic"] = "No"    elif type == "protected_areas":        protected = SpeciesPa.objects.filter(species_id=id)        response_data["species_id"] = id        response_data["protected_areas"] = [];        for item in protected:            p = item.pa_id            pa = {"pa_id": p.pa_id, "name": p.name, "designation": p.designation}            response_data["protected_areas"].append(pa)    else:        return HttpResponse(json.dumps(error_response), content_type="application/json")    return HttpResponse(json.dumps(response_data), content_type="application/json")def apiProtected(request, id, type):    try:        pa = ProtectedAreas.objects.get(pa_id=id)    except ProtectedAreas.DoesNotExist:        return HttpResponse(json.dumps(error_response), content_type="application/json")    response_data = {}    if type == "basics":        response_data = {"pa_id": pa.pa_id,                         "name": pa.name + " " + pa.designation,                         "type": pa.designation,                         "estd_year": pa.estd_year,                         "iucn_category": pa.iucn_category,                         "area": pa.area        }    elif type == "species_count":        response_data = ProtectedAreas.objects.speciesCount(id)    elif type == "species_checklist":        response_data = ProtectedAreas.objects.speciesChecklist(id)    else:        return HttpResponse(json.dumps(error_response), content_type="application/json")    return HttpResponse(json.dumps(response_data), content_type="application/json")def apiOthers(request, type, group="all"):    response_data = {}    if type == "count":        response_data = Species.objects.speciesCount(group)    elif type == "checklist":        response_data = Species.objects.speciesChecklist(group)    else:        return HttpResponse(json.dumps(error_response), content_type="application/json")    return HttpResponse(json.dumps(response_data), content_type="application/json")def csvProtectedChecklist(request, id):    try:        pa = ProtectedAreas.objects.get(pa_id=id)    except ProtectedAreas.DoesNotExist:        return HttpResponse(json.dumps(error_response), content_type="application/json")    import csv    response_data = ProtectedAreas.objects.speciesChecklist(id)    response = HttpResponse(mimetype='text/csv')    response['Content-Disposition'] = 'attachment;filename=export.csv'    field_names = ["Species ID", "Group", "Name"]    writer = csv.writer(response)    writer.writerow(field_names)    for group, species in response_data.iteritems():        for item in species:            writer.writerow([item['species_id'], group, item['name']])    return responsedef csvSpeciesChecklist(request, group='all'):    import csv    response_data = Species.objects.speciesChecklist(group)    response = HttpResponse(mimetype='text/csv')    response['Content-Disposition'] = 'attachment;filename=export.csv'    if group == 'all':        field_names = ["Species ID", "Group", "Name"]    else:        field_names = ["Species ID", "Family", "Name"]    writer = csv.writer(response)    writer.writerow(field_names)    for group, species in response_data.iteritems():        for item in species:            writer.writerow([item['species_id'], group, item['name']])    return responsedef threats(request, type, pa):    def getFullCategory(code):        if code == "LC": return "Least Concern"        if code == "NT": return "Near Threatened"        if code == "VU": return "Vulnerable"        if code == "EN": return "Endangered"        if code == "CR": return "Critically Endangered"        if code == "DD": return "Data Deficient"    if type == "iucn_category":        if int(pa) > 0:            species = SpeciesPa.objects.filter(pa_id=pa).values_list('species_id')            data = IucnData.objects.filter(species_id__in=species).values('status').annotate(Count('status'))        else:            data = IucnData.objects.all().values('status').annotate(Count('status'))        response_data = {'name': 'IUCN Category', 'children': []}        response_data['children'].append({'name': "Threatened", 'children': []})        for item in data:            if item['status'] in ['CR', 'EN', 'VU']:                response_data['children'][0]['children'].append(                        {'name': getFullCategory(item['status']), 'size': item['status__count']})            else:                response_data['children'].append(                        {'name': getFullCategory(item['status']), 'size': item['status__count']})    return HttpResponse(json.dumps(response_data), content_type="application/json")def classification_flare_json(request, pa_id):    pa_id = int(pa_id)    if pa_id > 0:        species_ids = SpeciesPa.objects.filter(pa_id=pa_id).values_list('species_id', flat=True)        clazz = Classification.objects.filter(species_id__in=species_ids).order_by('kingdom', 'phylum', 'class_field',            'order', 'family', 'genus', 'species_id').select_related()    else:        clazz = Classification.objects.all().order_by('kingdom', 'phylum', 'class_field', 'order', 'family', 'genus',            'species_id').select_related()    tree = {'name': "root", 'children': []}    def get_previous(type):        types = ['kingdom', 'phylum', 'class_field', 'order', 'family', 'genus', 'species_id']        n = types.index(type)        sub_tree = tree['children']        if not sub_tree: return None        for i in range(0, n):            if not sub_tree: return None            sub_tree = sub_tree[len(sub_tree) - 1]['children']        if not sub_tree: return None        last_item = sub_tree[len(sub_tree) - 1]        return last_item['name']    def append(type, item):        types = ['kingdom', 'phylum', 'class_field', 'order', 'family', 'genus', 'species_id']        n = types.index(type)        sub_tree = tree['children']        for i in range(0, n + 1):            if not sub_tree: return None            sub_tree = sub_tree[len(sub_tree) - 1]['children']        sub_tree.append(item)    for item in clazz:        while True:            if item.kingdom == get_previous('kingdom'):                if item.phylum == get_previous('phylum'):                    if item.class_field == get_previous('class_field'):                        if item.order == get_previous('order'):                            if item.family == get_previous('family'):                                if item.genus == get_previous('genus'):                                    append('genus', {'name': item.species_id.name, 'size': 1})                                    break;                                else:                                    append('family', {'name': item.genus, 'children': []})                            else:                                append('order', {'name': item.family, 'children': []})                        else:                            append('class_field', {'name': item.order, 'children': []})                    else:                        append('phylum', {'name': item.class_field, 'children': []})                else:                    append('kingdom', {'name': item.phylum, 'children': []})            else:                tree['children'].append({'name': item.kingdom, 'children': []})    return HttpResponse(json.dumps(tree), content_type="application/json")def classification_flare_json(request):    clazz = Classification.objects.all().order_by('kingdom', 'phylum', 'class_field', 'order', 'family', 'genus',        'species_id').select_related()    tree = {'name': "All Species", 'children': []}    def get_previous(type):        types = ['kingdom', 'phylum', 'class_field', 'order', 'family', 'genus', 'species_id']        n = types.index(type)        sub_tree = tree['children']        if not sub_tree: return None        for i in range(0, n):            if not sub_tree: return None            sub_tree = sub_tree[len(sub_tree) - 1]['children']        if not sub_tree: return None        last_item = sub_tree[len(sub_tree) - 1]        return last_item['name']    def append(type, item):        types = ['kingdom', 'phylum', 'class_field', 'order', 'family', 'genus', 'species_id']        n = types.index(type)        sub_tree = tree['children']        for i in range(0, n + 1):            if not sub_tree: return None            sub_tree = sub_tree[len(sub_tree) - 1]['children']        sub_tree.append(item)    for item in clazz:        while True:            if item.kingdom == get_previous('kingdom'):                if item.phylum == get_previous('phylum'):                    if item.class_field == get_previous('class_field'):                        if item.order == get_previous('order'):                            if item.family == get_previous('family'):                                if item.genus == get_previous('genus'):                                    append('genus', {'name': item.species_id.name, 'type': 'species', 'size': 1, 'id':item.species_id.species_id})                                    break;                                else:                                    append('family', {'name': item.genus, 'type': 'genus', 'children': []})                            else:                                append('order', {'name': item.family, 'type': 'family', 'children': []})                        else:                            append('class_field', {'name': item.order, 'type': 'order', 'children': []})                    else:                        append('phylum', {'name': item.class_field, 'type': 'class_field', 'children': []})                else:                    append('kingdom', {'name': item.phylum, 'type': 'phylum', 'children': []})            else:                tree['children'].append({'name': item.kingdom, 'type': 'kingdom', 'children': []})    return HttpResponse(json.dumps(tree), content_type="application/json")def count_family(request):    clazz = Classification.objects.all().select_related().order_by('kingdom', 'species_id__group', 'order',            'family').values('kingdom', 'species_id__group', 'phylum', 'class_field', 'order', 'family').annotate(            Count('family'))    tree = {'name': "All Species", 'children': []}    def get_previous(type):        types = ['kingdom', 'species_id__group', 'order', 'family']        n = types.index(type)        sub_tree = tree['children']        if not sub_tree: return None        for i in range(0, n):            if not sub_tree: return None            sub_tree = sub_tree[len(sub_tree) - 1]['children']        if not sub_tree: return None        last_item = sub_tree[len(sub_tree) - 1]        return last_item['name']    def append(type, item):        types = ['kingdom', 'species_id__group', 'order', 'family']        n = types.index(type)        sub_tree = tree['children']        for i in range(0, n + 1):            if not sub_tree: return None            sub_tree = sub_tree[len(sub_tree) - 1]['children']        sub_tree.append(item)    for item in clazz:        while True:            if item['kingdom'] == get_previous('kingdom'):                if item['species_id__group'] == get_previous('species_id__group'):                    if item['order'] == get_previous('order'):                        append('order', {'name': item['family'], 'size': item['family__count']})                        break;                    else:                        append('species_id__group', {'name': item['order'], 'children': []})                else:                    append('kingdom', {'name': item['species_id__group'], 'children': []})            else:                tree['children'].append({'name': item['kingdom'], 'children': []})    return HttpResponse(json.dumps(tree), content_type="application/json")def area_hierarchy(request):    pa = ProtectedAreas.objects.filter(area__gt=0).exclude(Q(description__contains='Redirect')).order_by('pa_id')    tree = {'name': "Protected Areas", 'children': []}    for item in pa:        found = False        for type in tree['children']:            if type['name'] == item.designation:                type['children'].append({'name': item.name, 'size': item.area})                found = True                break        if not found:            tree['children'].append({'name': item.designation, 'children': [{'name': item.name, 'size': item.area}]})    return HttpResponse(json.dumps(tree), content_type="application/json")def iucn_classification(request, type, group):    iucn_json = json.load(open("iucn.json"))    field_name = ""    if type == "threat":        iucn_no_dot = iucn_json['threat']        field_name = 'threat_number'        if group != "All":            species = Species.objects.filter(group = group).values_list('species_id',flat=True)            iucn_clazz = IucnThreat.objects.filter(species_id__in = species).values(field_name).annotate(Count(field_name)).order_by(field_name)        else:            iucn_clazz = IucnThreat.objects.values(field_name).annotate(Count(field_name)).order_by(field_name)            elif type == "habitat":        iucn_no_dot = iucn_json['habitat']        field_name = 'habitat_number'        if group != "All":            species = Species.objects.filter(group = group).values_list('species_id',flat=True)            iucn_clazz = IucnHabitat.objects.filter(species_id__in = species).values(field_name).annotate(Count(field_name)).order_by(field_name)        else:            iucn_clazz = IucnHabitat.objects.values(field_name).annotate(Count(field_name)).order_by(field_name)    elif type == "conservation":        iucn_no_dot = iucn_json['conservation']        field_name = 'conservation_number'        if group != "All":            species = Species.objects.filter(group = group).values_list('species_id',flat=True)            iucn_clazz = IucnConservation.objects.filter(species_id__in = species).values(field_name).annotate(Count(field_name)).order_by(field_name)        else:            iucn_clazz = IucnConservation.objects.values(field_name).annotate(Count(field_name)).order_by(field_name)    iucn = {}    for key, item in iucn_no_dot.items():        iucn[key + '.'] = item    tree = {'name': type, 'children': []}    def get_last(level):        sub_tree = tree['children']        for i in range(level):            if not sub_tree: return None            sub_tree = sub_tree[len(sub_tree) - 1]['children']        if not sub_tree: return None        return sub_tree[len(sub_tree) - 1]    for item in iucn_clazz:        lvl = item[field_name].split('.')        if len(lvl) == 3:            last = get_last(0)            if not last or last['id'] != lvl[0] + ".":                tree['children'].append({'name': iucn[lvl[0] + "."], 'id': lvl[0] + ".", 'children': []})                last = get_last(0)            last['children'].append({'name': iucn[item[field_name]], 'id': item[field_name],                                     'size': item[field_name + "__count"]})        elif len(lvl) == 4:            last = get_last(0)            if not last or last['id'] != lvl[0] + ".":                tree['children'].append({'name': iucn[lvl[0] + "."], 'id': lvl[0] + ".", 'children': []})                last = get_last(0)                last['children'].append(                        {'name': iucn[lvl[0] + "." + lvl[1] + "."], 'id': lvl[0] + "." + lvl[1] + ".", 'children': []})                last = get_last(1)                last['children'].append({'name': iucn[item[field_name]], 'id': item[field_name],                                         'size': item[field_name + "__count"]})            else:                last = get_last(1)                if not last or last['id'] != lvl[0] + "." + lvl[1] + ".":                    last = get_last(0)                    last['children'].append(                            {'name': iucn[lvl[0] + "." + lvl[1] + "."], 'id': lvl[0] + "." + lvl[1] + ".",                             'children': []})                    last = get_last(1)                    last['children'].append({'name': iucn[item[field_name]], 'id': item[field_name],                                             'size': item[field_name + "__count"]})                else:                    last['children'].append({'name': iucn[item[field_name]], 'id': item[field_name],                                             'size': item[field_name + "__count"]})    return HttpResponse(json.dumps(tree), content_type="application/json")def json_hierarchy2dict(tree):    if tree["name"] == "Desert\r\n":        print "here!"    if not "children" in tree['children'][0]:        d = {}        for item in tree['children']:            if "size" in item:                d[item['name']] = item['size']            else:                d[item['name']] = json_hierarchy2dict(item)        print d        return d    else:        d = {}        for item in tree['children']:            d[item['name']] = json_hierarchy2dict(item)        print d        return ddef piechart_json(request, type, group = None):    response = {}    if type == "pa_count":        c = ProtectedAreas.objects.exclude(Q(designation = "World Heritage Site")| Q(designation = "National Park - Buffer Zone")).values('designation').annotate(total=Count('designation')).order_by('designation')        for item in c:            item["label"] = item.pop("designation")            item["value"] = item.pop("total")        response = ValuesQuerySetToDict(c)    elif type == "pa_area":        c = ProtectedAreas.objects.exclude(Q(designation = "World Heritage Site")| Q(designation = "National Park - Buffer Zone")).values('designation').annotate(total=Sum('area')).order_by('designation')        for item in c:            item["label"] = item.pop("designation")            item["value"] = item.pop("total")        response = ValuesQuerySetToDict(c)    elif type == "redlist":        if group == "All":            r = IucnData.objects.all().values('status').annotate(Count('status'))        else:            species_list = Species.objects.filter(group = group).values_list('species_id',flat=True)            r = IucnData.objects.filter(species_id__in = species_list).values('status').annotate(Count('status'))        threatened = 0        for item in r:            if item["status"] in ["CR", "EN", "VU"]:                threatened += item["status__count"]                continue            item["label"] = item.pop("status")            item["value"] = item.pop("status__count")        myDict = ValuesQuerySetToDict(r)        myDict[:] = [d for d in myDict if d.get('status') not in ["CR", "EN", "VU"]]        myDict.append({'label':"Threatened", 'value':threatened})        chk = ["NT","LC","DD","Threatened"]        for c in chk:            found = False            for item in myDict:                if item['label'] == c:                    found = True                    break            if not found:                myDict.append({'label':c, 'value':0})        response = myDict    elif type=="redlist_th":        if group == "All":            r = IucnData.objects.all().filter(status__in = ["CR", "VU", "EN"]).values('status').annotate(Count('status'))        else:            species_list = Species.objects.filter(group = group).values_list('species_id',flat=True)            r = IucnData.objects.filter(species_id__in = species_list, status__in = ["CR", "VU", "EN"]).values('status').annotate(Count('status'))        for item in r:            item["label"] = item.pop("status")            item["value"] = item.pop("status__count")        response = ValuesQuerySetToDict(r)        chk = ["CR", "VU", "EN"]        for c in chk:            found = False            for item in response:                if item['label'] == c:                    found = True                    break            if not found:                response.append({'label':c, 'value':0})    elif type == "cites":        if group == "All":            c = Status.objects.exclude(cites = "NULL").values('cites').annotate(Count('cites')).order_by("cites")        else:            species_list = Species.objects.filter(group = group).values_list('species_id',flat=True)            c = Status.objects.filter(species_id__in = species_list).exclude(cites = "NULL").values('cites').annotate(Count('cites')).order_by("cites")        for item in c:            item["label"] = item.pop("cites")            item["value"] = item.pop("cites__count")        response = ValuesQuerySetToDict(c)    elif type == "nrdb":        if group == "All":            c = Status.objects.exclude(Q(nrdb = "NULL")|Q(nrdb = "")).values('nrdb').annotate(Count('nrdb')).order_by("nrdb")        else:            species_list = Species.objects.filter(group = group).values_list('species_id',flat=True)            c = Status.objects.filter(species_id__in = species_list).exclude(nrdb = "NULL").values('nrdb').annotate(Count('nrdb')).order_by("nrdb")        values = ["EXN", "C", "E", "V", "S", "I", "UR"]        retDict = []        for item in values:            retDict.append({'label': item, 'value': 0})        for item in c:            for value in retDict:                if item["nrdb"] == value["label"]:                    value["value"] = item["nrdb__count"]        response = ValuesQuerySetToDict(retDict)    elif type == "zoo_species":        zs = Zoo.objects.values('group').annotate(Count('group'))        retDict = []        for item in zs:            retDict.append({"label":item['group'], "value":item['group__count']})        response = retDict    elif type == "zoo_count":        zs = Zoo.objects.values('group').annotate(total = Sum('id', field='"Male"+"Female"+"Unknown"'))        retDict = []        for item in zs:            retDict.append({"label":item['group'], "value":item['total']})        response = retDict    return HttpResponse(json.dumps(response), content_type="application/json")def ValuesQuerySetToDict(vqs):    return [item for item in vqs]def stackedbar_json(request, type, id = None):    response = []    if type == "pa_fauna_count":        pa = SpeciesPa.objects.all().distinct('pa_id').select_related()        response = []        for item in pa:            p = item.pa_id            c = ProtectedAreas.objects.speciesCount(p.pa_id)            if "Phanerogams" in c: del c["Phanerogams"]            if "Pteridophytes" in c: del c["Pteridophytes"]            if not "Fish" in c: c["Fish"] = 0            if not "Herpeto" in c: c["Herpeto"] = 0            init = ""            for line in (p.name + " " + p.designation).split():                init += line[0][0].upper()            c["PA"] = init            response.append(c)    elif type == "pa_flora_count":        pa = SpeciesPa.objects.all().distinct('pa_id').select_related()        response = []        for item in pa:            p = item.pa_id            c = ProtectedAreas.objects.speciesCount(p.pa_id)            fauna = ["Fish", "Herpeto", "Birds", "Mammal"]            for x in fauna:                if x in c: del c[x]            if not "Phanerogams" in c: c["Phanerogams"] = 0            if not "Pteridophytes" in c: c["Pteridophytes"] = 0            if c["Phanerogams"] == 0 and c["Pteridophytes"] == 0:                continue            init = ""            for line in (p.name + " " + p.designation).split():                init += line[0][0].upper()            c["PA"] = init            response.append(c)    elif type == "pa_fauna":        species_list = SpeciesPa.objects.filter(pa_id = id).exclude(Q(species_id__group = "Phanerogams")|Q(species_id__group = "Pteridophytes")).values_list('species_id',flat=True)        iucn = IucnData.objects.filter(species_id__in = species_list).exclude(Q(status = "LC") | Q(status = "DD")).values('species_id__group','status').annotate(Count('status')).order_by('species_id__group')        response = []        prev = None        for item in iucn:            if prev and prev["Group"] == item["species_id__group"]:                prev[item["status"]] = item["status__count"]            else:                record = {"Group":item["species_id__group"], "NT":0, "VU":0, "EN":0, "CR":0}                record[item["status"]]= item["status__count"]                response.append(record)            prev = response[len(response)-1]    elif type == "zoo_gender":        gender = Zoo.objects.values('group').annotate(male = Sum('male'), female = Sum('female'), unknown = Sum('unknown'))    return HttpResponse(json.dumps(response), content_type="application/json")def bar_chart_json(request, type, id = None):    response = []    if type == "pa_species":        data = ProtectedAreas.objects.speciesCount(id)        for key, item in data.iteritems():            record = dict()            record["name"] = key            record["value"] = item            response.append(record)        from operator import itemgetter        response = sorted(response, key=itemgetter('value'), reverse=True)    return HttpResponse(json.dumps(response), content_type="application/json")def search(request,type, keyword):    result = {}    if type == "species":        result = Species.objects.filter(name__icontains = keyword).values('name', 'group')    elif type == "common":        result = CommonNames.objects.filter(common_name__icontains = keyword).distinct('common_name').select_related().values('species_id__name','species_id__group', 'common_name')    return HttpResponse(json.dumps(ValuesQuerySetToDict(result)), content_type="application/json")